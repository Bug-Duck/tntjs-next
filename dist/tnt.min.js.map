{"version":3,"file":"tnt.min.js","sources":["../node_modules/tslib/tslib.es6.js","../src/lib/common.ts","../src/reactivity.ts","../src/renderers/attributeRenderer.ts","../src/renderers/conditionRenderer.ts","../src/renderers/index.ts","../src/renderers/variableRenderer.ts","../src/renderers/loopRenderer.ts","../src/vdom.ts","../src/index.ts"],"sourcesContent":["/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n        desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n\r\nexport function __classPrivateFieldIn(state, receiver) {\r\n    if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\r\n    return typeof state === \"function\" ? receiver === state : state.has(receiver);\r\n}\r\n","/**\n * Deep clone an object.\n * @param obj Object to clone.\n * @returns Deep cloned object.\n */\nexport const deepClone = (obj: any) => {\n  const newObj: any = {};\n  for (const key in obj) {\n    if (typeof key === \"object\") {\n      newObj[key] = deepClone(obj[key]);\n      continue;\n    }\n    newObj[key] = obj[key];\n  }\n  return newObj;\n};\n\n/**\n * Evaluate an expression.\n * @param expression Expression to evaluate its value.\n * @param extraContext Some extra context to inject.\n * @param shouldExecuate Whether or not to execuate the generated function.\n * @returns Evaluated result or error message.\n */\nexport const evaluate = (\n  expression: string,\n  extraContext = {},\n  shouldExecuate = true\n) => {\n  try {\n    const func = Function(\"ctx\", `with(ctx) {return ${expression};}`);\n    return shouldExecuate ? func(extraContext) : func;\n  } catch (e) {\n    return e.toString();\n  }\n};\n","/** An effect to be ran when its dependencies change. */\nexport type EffectType = () => void;\n/** Objects that can be reactive. */\nexport type ReactiveType = object;\n/** Map to store reactive object - dependencies - effects data. */\ntype TargetMap = WeakMap<ReactiveType, Map<string, Set<EffectType>>>;\n\n/** Currently active running effects. */\nconst activeEffects: EffectType[] = [];\n/** {@inheritDoc TargetMap} */\nexport const targetMap: TargetMap = new WeakMap<TargetMap>();\n\n/** Callbasks when a trackable object changes. */\ninterface TrackableCallback {\n  onGet: (target: ReactiveType, key: string, receiver: any) => void;\n  onSet: (\n    target: ReactiveType,\n    key: string,\n    value: ReactiveType,\n    receiver: any\n  ) => void;\n  onDeleteProperty: (target: ReactiveType, key: string) => void;\n}\n\n/**\n * Get a trackable proxy object and fire certain callbacks on certain events.\n * @param obj The object to track updates.\n * @param callbacks Callbacks to run when certain event was fired.\n * @returns A proxy to the original object.\n */\nexport const getTrackableObject = (\n  obj: ReactiveType,\n  callbacks: TrackableCallback\n) => {\n  for (const key in obj) {\n    if (typeof obj[key] === \"object\") {\n      obj[key] = getTrackableObject(obj[key], callbacks);\n    }\n  }\n  const proxy = new Proxy(obj, {\n    get(target: ReactiveType, key: string, receiver: any) {\n      const result = Reflect.get(target, key, receiver);\n      callbacks.onGet(target, key, receiver);\n      return result;\n    },\n    set(target: ReactiveType, key: string, value: object, receiver: any) {\n      if (typeof value === \"object\") {\n        value = getTrackableObject(value, callbacks);\n      }\n      const result = Reflect.set(target, key, value, receiver);\n      callbacks.onSet(target, key, value, receiver);\n      return result;\n    },\n    deleteProperty(target: ReactiveType, key: string) {\n      const result = Reflect.deleteProperty(target, key);\n      callbacks.onDeleteProperty(target, key);\n      return result;\n    },\n  });\n  if (Array.isArray(obj)) {\n    Object.setPrototypeOf(proxy, Array.prototype);\n  }\n  return proxy;\n};\n\n/**\n * Track the current running effect's dependencies.\n * @param target The reactive object to track.\n * @param key The key to fetch data from.\n */\nexport const track = (target: object, key: string) => {\n  if (!activeEffects.length) return;\n  let depsMap = targetMap.get(target);\n  if (!depsMap) {\n    depsMap = new Map();\n    targetMap.set(target, depsMap);\n  }\n  let dep = depsMap.get(key);\n  if (!dep) {\n    // using set assures that no duplicate effects will be stored\n    dep = new Set();\n    depsMap.set(key, dep);\n  }\n  activeEffects.forEach((effect) => dep.add(effect));\n};\n\n/**\n * Trigger effects of certain dependencies.\n * @param target The reactive object to trigger effects.\n * @param key The key to fetch dependencies from.\n */\nexport const trigger = (target: ReactiveType, key: string) => {\n  const depsMap = targetMap.get(target);\n  if (!depsMap) return;\n  const deps = depsMap.get(key);\n  if (!deps) return;\n\n  deps.forEach((effect) => {\n    effect();\n  });\n};\n\n/**\n * Watch an effect's dependencies.\n * @param effect Effect to run when its dependencies changed.\n */\nexport const watchEffect = (effect: EffectType) => {\n  activeEffects.push(effect);\n  effect();\n  activeEffects.pop();\n};\n\n/**\n * Create a reactive object and enable two-way auto update.\n * @param target The object to be made reactive.\n * @returns The proxied reactive object.\n */\nexport const reactive = (target: ReactiveType) => {\n  return getTrackableObject(target, {\n    onGet(target, key) {\n      track(target, key);\n    },\n    onSet(target, key) {\n      trigger(target, key);\n    },\n    onDeleteProperty() {},\n  });\n};\n\n/**\n * Create a reactive reference to a plain value.\n * @param raw A raw value to be reactive.\n * @returns The proxied object with `.value` getters and setters.\n */\nexport const ref = (raw: ReactiveType) => {\n  const r = {\n    get value() {\n      track(r, \"value\");\n      return raw;\n    },\n    set value(newVal) {\n      if (newVal === raw) return;\n      raw = newVal;\n      trigger(r, \"value\");\n    },\n  };\n  return r;\n};\n\n/**\n * Create a reactive computed value.\n * @note `computed` is built on top of {@link ref} API. Any updates must be using `.value` accessor.\n * @param getter Function to calculate the computed value.\n * @returns A reference object to the computed value.\n */\nexport const computed = (getter: () => ReactiveType) => {\n  const result = ref(null);\n  watchEffect(() => (result.value = getter()));\n  return result;\n};\n","import { evaluate } from \"../lib/common\";\nimport { watchEffect } from \"../reactivity\";\nimport { VNode } from \"../vdom\";\nimport { Renderer } from \"./index\";\n\n/**\n * Render attribute bindings.\n * @param currentNode Current VNode to render.\n * @param extraContext Some extra context to inject.\n * @returns Whether to continue rendering `currentNode`'s children or not.\n */\nconst attributeRenderer = (currentNode: VNode, extraContext: object) => {\n  for (const key in currentNode.props) {\n    if (!key.startsWith(\":\")) continue;\n    if (key.startsWith(\":on\")) {\n      console.warn(\n        \"[TNT warn] Using reactive binding and event listeners at the same time will cause the program to run not as expected.\",\n        \"Please extract logic or remove one of the effect bindings.\"\n      );\n    }\n    // original attribute is no longer needed\n    currentNode.el.removeAttribute(key);\n    watchEffect(() => {\n      currentNode.el.setAttribute(\n        key.slice(1),\n        evaluate(currentNode.props[key], extraContext)\n      );\n    });\n  }\n  return true;\n};\n\nconst renderer: Renderer = {\n  renderer: attributeRenderer,\n  name: \"attributeRenderer\",\n  shouldFire(node) {\n    for (const key in node.props) {\n      if (key.startsWith(\":\")) return true;\n    }\n    return false;\n  },\n};\n\nexport default renderer;\n","import { evaluate } from \"../lib/common\";\nimport { watchEffect } from \"../reactivity\";\nimport { VNode } from \"../vdom\";\nimport { Renderer } from \"./index\";\n\n/** Condition tags with `props.cond` property. */\nexport const TAGS_WITH_CONDITION = [\"t-if\", \"t-elif\"];\n/** All condition tags, discarding its actual condition. */\nexport const CONDITION_TAGS = [\"t-if\", \"t-elif\", \"t-else\"];\n\n/**\n * Render a `<t-if />` element.\n * This renderer will render its children if `currentNode.props.cond` returns a truthy value, not rendering otherwise.\n * @param currentNode Current node to check condition.\n * @param extraContext Some extra variable context to inject.\n * @returns Whether should continue to render currentNode's children.\n */\nconst ifRenderer = (currentNode: VNode, extraContext: string) => {\n  let shouldRender = false;\n  watchEffect(() => {\n    const result = evaluate(currentNode.props.cond, extraContext);\n    shouldRender = !!result;\n    currentNode.props.rendered = shouldRender.toString();\n  });\n  return shouldRender;\n};\n\n/**\n * Render a `<t-elif />` element.\n * This renderer will only render `currentNode`'s children if its previous element sibling is a `<t-if />` or `<t-elif />`\n * and its previoud element's condition is a falsy value.\n * @param currentNode Current node to render.\n * @param extraContext Some extra variable context to inject.\n * @param rootVNode The root VNode of `currentNode`.\n * @param index The position of `currentNode` in `rootVNode.children`.\n * @returns Whether to continue to render currentNode's children nodes.\n */\nconst elifRenderer = (\n  currentNode: VNode,\n  extraContext: object,\n  rootVNode: VNode,\n  index: number\n) => {\n  let shouldRender = false;\n  const previousElement = (rootVNode.children as VNode[])[\n    rootVNode.children.length - 1\n  ];\n  if (\n    index - 1 === 0 ||\n    !TAGS_WITH_CONDITION.includes(previousElement.tag) ||\n    previousElement.props.rendered === \"true\"\n  )\n    return false;\n  watchEffect(() => {\n    const result = evaluate(currentNode.props.cond, extraContext);\n    shouldRender = !!result;\n    currentNode.props.rendered = shouldRender.toString();\n  });\n  return shouldRender;\n};\n\n/**\n * Render a `<t-else />` element.\n * This renderer will only render if `currentNode`'s previous element is a valid condition element AND its condition\n * is a falsy value.\n * @param currentNode Current node to render.\n * @param extraContext Some extra context to inject.\n * @param rootVNode The root VNode of `currentNode`.\n * @param index The position of `currentNode` in `rootVNode.children`.\n * @returns Whether to continue to render currentNode's children elements.\n */\nconst elseRenderer = (\n  currentNode: VNode,\n  extraContext: object,\n  rootVNode: VNode,\n  index: number\n) => {\n  let shouldRender = false;\n  const previousElement = (rootVNode.children as VNode[])[\n    rootVNode.children.length - 1\n  ];\n  if (index - 1 === 0 || !TAGS_WITH_CONDITION.includes(previousElement.tag))\n    return false;\n  watchEffect(() => {\n    const result = evaluate(previousElement.props.cond, extraContext);\n    shouldRender = !result;\n    currentNode.props.rendered = shouldRender.toString();\n  });\n  return shouldRender;\n};\n\n/**\n * Render condition tags.\n * This renderer will only render if the condition of current element is truthy and its corresponding builtin\n * conditions met the requirements.\n * @see {@link ifRenderer}, {@link elifRenderer}, {@link elseRenderer}\n * @param currentNode Current node to render.\n * @param extraContext Some extra context to inject.\n * @param rootVNode The root VNode of `currentNode`.\n * @param index The position of `currentNode` in `rootVNode.children`.\n * @returns Whether to continue render currentNode's children elements.\n */\nconst conditionRenderer = (\n  currentNode: VNode,\n  extraContext: object,\n  rootVNode: VNode,\n  index: number\n) => {\n  let currentRenderer = null;\n  if (currentNode.tag === \"t-if\") {\n    currentRenderer = ifRenderer;\n  } else if (currentNode.tag === \"t-elif\") {\n    currentRenderer = elifRenderer;\n  } else {\n    currentRenderer = elseRenderer;\n  }\n  return currentRenderer(currentNode, extraContext, rootVNode, index);\n};\n\nconst renderer: Renderer = {\n  renderer: conditionRenderer,\n  name: \"conditionRenderer\",\n  shouldFire(node) {\n    return CONDITION_TAGS.includes(node.tag);\n  },\n};\n\nexport default renderer;\n","import { VNode } from \"../vdom\";\nimport variableRenderer from \"./variableRenderer\";\nimport conditionRenderer from \"./conditionRenderer\";\nimport loopRenderer from \"./loopRenderer\";\nimport attributeRenderer from \"./attributeRenderer\";\n\n/** Return values for rendered contents. */\nexport interface RenderedContent {\n  /** Weather the current node should render on page. */\n  shouldRender: boolean;\n  /** A collection of variable values to inject into the children renderers. */\n  injectVariables?: Record<string, string>;\n}\n\n/** A standard renderer model for builtin or custom renderers. */\nexport interface Renderer {\n  /**\n   * The main renderer function.\n   * @param currentNode VNode to render.\n   * @param extraContext Some extra variable context to render the content\n   * @param rootVNode Root VNode of the currently rendering VNode.\n   * @param index The current position of currentNode in rootVNode's children list.\n   * @returns Whether to render currentNode's children elements if returned a boolean, higher level reference elsewise (see {@link RenderedContent}).\n   */\n  renderer: (\n    currentNode: VNode,\n    extraContext: object,\n    rootVNode: VNode,\n    index: number\n  ) => boolean | RenderedContent;\n  /** Name of current renderer, only for debugging purposes. */\n  name: string;\n  /**\n   * Function to check whether current node should be called with current renderer.\n   * @param node Current VNode to check.\n   * @returns Whether to call current render function or not.\n   */\n  shouldFire: (node: VNode) => boolean;\n}\n\nconst renderers: Renderer[] = [\n  variableRenderer,\n  conditionRenderer,\n  loopRenderer,\n  attributeRenderer,\n];\n\nexport default {\n  /** Builtin renderers. */\n  renderers,\n};\n","import { evaluate } from \"../lib/common\";\nimport { watchEffect } from \"../reactivity\";\nimport { VNode } from \"../vdom\";\nimport { Renderer } from \"./index\";\n\n/**\n * Render a variable (`<v />` tag).\n * @param currentNode Node that need to be rendered.\n * @param extraContext Some extra context to inject.\n * @returns Whether to continue render `currentNode`'s children elements.\n */\nconst variableRenderer = (currentNode: VNode, extraContext: object) => {\n  watchEffect(() => {\n    currentNode.children = [\n      evaluate(currentNode.props.data, extraContext).toString(),\n    ];\n  });\n  return true;\n};\n\nconst renderer: Renderer = {\n  renderer: variableRenderer,\n  name: \"variableRenderer\",\n  shouldFire(node) {\n    return node.tag === \"v\";\n  },\n};\n\nexport default renderer;\n","import { deepClone, evaluate } from \"../lib/common\";\nimport {\n  createVdomFromExistingElement,\n  createVNodeFromElement,\n  VNode,\n} from \"../vdom\";\nimport { Renderer } from \"./index\";\n\n/**\n * Render a `<t-for />` loop.\n * @param currentNode Currently rendering VNode.\n * @param extraContext Some extra context to fill in to the evaluation process.\n * @returns Whether to continue rendering its children or not.\n */\nconst loopRenderer = (currentNode: VNode, extraContext: object) => {\n  const expr = currentNode.props.data.split(\" in \");\n  const localName = expr[0].trim();\n  const loopingValue = evaluate(expr[1].trim(), extraContext);\n  const originalChild: Element = deepClone(currentNode.el.children[0]);\n  for (const currentData of loopingValue) {\n    const currentChild = createVNodeFromElement(originalChild);\n    // custom rendering logic\n    createVdomFromExistingElement(currentChild, currentChild.el, {\n      ...extraContext,\n      [localName]: currentData,\n    });\n    (currentNode.children as VNode[]).push(currentChild);\n  }\n  // do not render its children since they're already rendered\n  return false;\n};\n\nconst renderer: Renderer = {\n  renderer: loopRenderer,\n  name: \"loopRenderer\",\n  shouldFire(node) {\n    return node.tag === \"t-for\";\n  },\n};\n\nexport default renderer;\n","import { evaluate } from \"./lib/common\";\nimport attributeRenderer from \"./renderers/attributeRenderer\";\nimport renderers from \"./renderers/index\";\n\nexport type VNodeChild = VNode | string;\n\n/** A Virtual Node representation. */\nexport interface VNode {\n  /** Node tag name. */\n  tag: string;\n  /** Node properties */\n  props: Record<string, string>;\n  /** Node children */\n  children: VNodeChild[];\n  /** Actual element in DOM for the current VNode. */\n  el: Element;\n}\n\n/**\n * Constructs a VNode.\n * @param tag Tag name.\n * @param props Tag attributes / properties.\n * @param children Tag children.\n * @param el Tag actual DOM element\n * @returns Constructed Virtual DOM Node.\n */\nexport const h = (\n  tag: string,\n  props: Record<string, string> = {},\n  children: VNodeChild[],\n  el?: Element\n): VNode => {\n  return { tag, props, children, el };\n};\n\n/**\n * Mounts a VNode to an actual DOM element.\n * @param vnode The root VNode to mount with.\n * @param container The container DOM element to contain all generated nodes.\n * @returns The container element with generated nodes appended.\n */\nexport const mount = (\n  vnode: VNode,\n  container: Element,\n  extraContext: object = {}\n) => {\n  const el = (vnode.el = document.createElement(vnode.tag));\n  // processing props\n  for (const key in vnode.props) {\n    const value = vnode.props[key];\n    if (key.startsWith(\"on\")) {\n      el.addEventListener(\n        key.slice(2).toLowerCase(),\n        evaluate(value, extraContext)\n      );\n      vnode.el.removeAttribute(key);\n      continue;\n    }\n    el.setAttribute(key, value);\n  }\n  // TODO: refactor renderer fire logic for mounting\n  if (attributeRenderer.shouldFire(vnode))\n    attributeRenderer.renderer(vnode, extraContext);\n\n  // processing children\n  if (typeof vnode.children === \"string\") {\n    el.textContent = vnode.children;\n    container.appendChild(el);\n    return;\n  }\n  vnode.children.forEach((child) => {\n    if (typeof child === \"string\") {\n      el.appendChild(document.createTextNode(child));\n      return;\n    }\n    mount(child, el, extraContext);\n  });\n  container.appendChild(el);\n  return container;\n};\n\n/**\n * Patches the current actual element to a new VNode and replace the older one.\n * Note that this function will modify the DOM.\n * @param n1 The old VNode to be replaced.\n * @param n2 The newer VNode to update the current DOM to.\n */\nexport const patch = (n1: VNode, n2: VNode, extraContext: object = {}) => {\n  if (n1.tag === n2.tag) {\n    const el = (n2.el = n1.el);\n    // props\n    const oldProps = n1.props || {};\n    const newProps = n2.props || {};\n    for (const key in newProps) {\n      const oldValue = oldProps[key];\n      const newValue = newProps[key];\n      if (newValue === oldValue) continue;\n      el.setAttribute(key, newValue);\n    }\n    for (const key in oldProps) {\n      if (!(key in newProps)) {\n        el.removeAttribute(key);\n      }\n    }\n\n    // children\n    const oldChildren = n1.children;\n    const newChildren = n2.children;\n    const commonLength = Math.min(oldChildren.length, newChildren.length);\n    for (let i = 0; i < commonLength; i++) {\n      const oldChild = oldChildren[i];\n      const newChild = newChildren[i];\n      if (typeof oldChild === \"string\") {\n        if (typeof newChild === \"string\") {\n          if (oldChild !== newChild) {\n            el.replaceChild(\n              document.createTextNode(newChild),\n              el.childNodes[i]\n            );\n          }\n          continue;\n        }\n      }\n      patch(oldChild as VNode, newChild as VNode);\n    }\n    if (newChildren.length > oldChildren.length) {\n      newChildren.slice(oldChildren.length).forEach((child: VNode) => {\n        if (typeof child === \"string\") {\n          el.appendChild(document.createTextNode(child));\n          return;\n        }\n        mount(child, el, extraContext);\n      });\n      return;\n    }\n    if (newChildren.length < oldChildren.length) {\n      oldChildren\n        .slice(newChildren.length)\n        .forEach((child: VNodeChild, index) => {\n          if (typeof child === \"string\") {\n            el.removeChild(el.childNodes[index]);\n            return;\n          }\n          el.removeChild(child.el);\n        });\n      return;\n    }\n    return;\n  }\n  throw new Error(\"Replacing root elements are not supported.\");\n};\n\n/**\n * Helper function to get and convert attributes from an element to use the object structure.\n * @param element The element to get attributes from.\n * @returns Attributes in a single object-like structure.\n */\nexport const getAttributesOfElement = (\n  element: Element\n): Record<string, string> => {\n  const attributes = {};\n  for (let i = 0; i < element.attributes.length; i++)\n    attributes[element.attributes[i].name] = element.attributes[i].value;\n  return attributes;\n};\n\n/**\n * Generates a new VNode from existing elemnt.\n * @param rootVNode The root VNode to append children to.\n * @param container The container element to generate VNodes from.\n * @param extraContext Some extra context data to pass to `evaulate()`.\n */\nexport const createVdomFromExistingElement = (\n  rootVNode: VNode,\n  container: Element,\n  extraContext: object = {}\n) => {\n  [...container.childNodes].forEach((child: Element, index) => {\n    if (child.nodeType === Node.TEXT_NODE) {\n      if (!child.textContent.trim()) return;\n      rootVNode.children.push(child.textContent);\n      return;\n    }\n    // only generate text node and element node\n    if (child.nodeType !== Node.ELEMENT_NODE) {\n      return;\n    }\n    let shouldRender = true;\n    let injectContext = extraContext;\n    const currentNode = h(\n      child.tagName.toLowerCase(),\n      getAttributesOfElement(child),\n      []\n    );\n    currentNode.el = child;\n    // fire renderers\n    renderers.renderers.forEach((renderer) => {\n      if (!renderer.shouldFire(currentNode)) return;\n      const renderResult = renderer.renderer(\n        currentNode,\n        injectContext,\n        rootVNode,\n        index\n      );\n      if (typeof renderResult === \"boolean\") {\n        shouldRender = !renderResult ? renderResult : shouldRender;\n        return;\n      }\n      shouldRender = renderResult.shouldRender || shouldRender;\n      injectContext = { ...injectContext, ...renderResult.injectVariables };\n    });\n    if (shouldRender) {\n      createVdomFromExistingElement(currentNode, child, injectContext);\n    }\n    (rootVNode.children as VNode[]).push(currentNode);\n  });\n};\n\n/**\n * Create a new VNode from the given element.\n * Note: this function will not generate children nodes. To include children generation,\n * please use {@link createVdomFromExistingElement}.\n * @param node Element to create VNode from.\n * @returns The generated VNode object.\n */\nexport const createVNodeFromElement = (node: Element): VNode => {\n  return h(node.tagName.toLowerCase(), getAttributesOfElement(node), [], node);\n};\n","import { deepClone } from \"./lib/common\";\nimport { computed, reactive, ref, trigger, watchEffect } from \"./reactivity\";\nimport {\n  createVdomFromExistingElement,\n  getAttributesOfElement,\n  h,\n  mount,\n  patch,\n  VNode,\n} from \"./vdom\";\n\nexport type TNTData = object;\n\nexport type TNTEffect = () => any;\n\nexport type TNTComputed = Record<string, TNTEffect>;\n\n// tweak the Window object a bit to pass type check\ndeclare global {\n  export interface Window {\n    data: TNTData;\n  }\n}\n\n/** Create a new TNTjs application. */\nexport class TNTApp {\n  /** Reactive data object */\n  #reactiveData: object;\n  /** Computed data object */\n  #computedData: object;\n  /** Reference-value data object */\n  #refData: object;\n  /** Helper proxy for watching modifications on data */\n  #dataProxy: object;\n  /** Original data passed into {@link TNTApp.useData()} */\n  #originalData: object;\n  /** Function to run when application was first mounted */\n  #onMounted: (app: TNTApp) => void;\n  /** Helper array for storing currently called `TNTApp.use*` hooks. */\n  #hooksCalled: string[];\n  /** Effects watched in {@link TNTApp.useEffect()} */\n  #watchEffects: TNTEffect[];\n\n  constructor() {\n    this.#onMounted = () => {};\n    this.#hooksCalled = [];\n    this.#computedData = {};\n    this.#reactiveData = {};\n    this.#refData = {};\n    this.#watchEffects = [];\n    this.#originalData = {};\n    window.data = {};\n  }\n\n  /**\n   * Initialize and mount a new TNT Application.\n   * @param container The container element to mount with.\n   * @returns Mounted TNTApp instance.\n   */\n  mount(container: Element) {\n    let isMounted = false;\n    let prevVdom: VNode | null = null;\n    let currentNode = null;\n    this.#hooksCalled.push(\"mount\");\n\n    // app lifecycle loop\n    watchEffect(() => {\n      const currentContainer = currentNode?.el ?? container.children[0];\n      const vnode = h(\n        currentContainer.tagName,\n        getAttributesOfElement(currentContainer),\n        []\n      );\n      const extraContext = {\n        ...this.#reactiveData,\n      };\n      // normalization for ref-based data\n      for (const key in this.#computedData) {\n        // commented code will not update when running attribute renderer\n        // FIXME: fix inconsistent reaction of updating ref-based data\n        // extraContext[key] = this.#computedData[key].value;\n        extraContext[key] = this.#computedData[key];\n      }\n      for (const key in this.#refData) {\n        // FIXME: fix inconsistent reaction of updating ref-based data\n        // extraContext[key] = this.#refData[key].value;\n        extraContext[key] = this.#refData[key];\n      }\n      vnode.el = currentContainer;\n      createVdomFromExistingElement(vnode, currentContainer, extraContext);\n      currentNode = h(\n        container.tagName,\n        getAttributesOfElement(currentContainer),\n        vnode.children,\n        currentContainer\n      );\n      if (!isMounted) {\n        prevVdom = deepClone(currentNode);\n        mount(prevVdom, container, extraContext);\n        isMounted = true;\n        this.#removeUpdatedElements(container, currentContainer);\n        this.#onMounted(this);\n        return;\n      }\n      const newVdom: VNode = deepClone(currentNode);\n      patch(prevVdom, newVdom, extraContext);\n      prevVdom = deepClone(newVdom);\n      this.#removeUpdatedElements(container, currentContainer);\n    });\n\n    return this;\n  }\n\n  /** All defined reactive / ref data. */\n  get data() {\n    return this.#dataProxy;\n  }\n\n  /**\n   * Generate a new TNT data proxy based on reactive and computed data.\n   * The generated proxy will watch for re-assignments as well as reading values and handle edge cases.\n   * @returns Proxied TNT data object.\n   */\n  #getDataProxy() {\n    type MixedTarget = { reactive: object; computed: object; ref: object };\n\n    const syncData = (target: MixedTarget, prop: string, value: object) => {\n      // edge-case handling for re-assgining arrays\n      if (Array.isArray(value)) {\n        // re-creating the reactive array will drop its former effects\n        // so for work-around this will clear the array and push new elements into it\n        // TODO: improve performance for re-assigning reactive arrays\n        target.reactive[prop].splice(0, target.reactive[prop].length);\n        target.reactive[prop].push(...value);\n      }\n      // manually trigger an update\n      trigger(this.#originalData, prop);\n    };\n\n    const handlers = {\n      get(target: MixedTarget, prop: string) {\n        if (prop in target.reactive) {\n          return target.reactive[prop];\n        }\n        if (prop in target.computed) {\n          return target.computed[prop].value;\n        }\n        if (prop in target.ref) {\n          return target.ref[prop].value;\n        }\n        console.warn(\n          `[TNT warn] You accessed a value not defined (Reading '${prop}').`\n        );\n        return undefined;\n      },\n      set(target: MixedTarget, prop: string, value: object) {\n        if (prop in target.reactive) {\n          syncData(target, prop, value);\n          return true;\n        }\n        if (prop in target.ref) {\n          target.ref[prop].value = value;\n          return true;\n        }\n        console.warn(\n          `[TNT warn] You set a value not defined (Reading '${prop}').`\n        );\n        return false;\n      },\n    };\n\n    return new Proxy(\n      {\n        reactive: this.#reactiveData,\n        computed: this.#computedData,\n        ref: this.#refData,\n      },\n      handlers\n    );\n  }\n\n  /**\n   * Hook to create reactive data objects.\n   * @param data Data to become reactive.\n   * @returns Current `TNTApp` instance.\n   */\n  useData(data: TNTData) {\n    this.#hooksCalled.push(\"data\");\n    this.#originalData = deepClone(data);\n    this.#reactiveData = {};\n    this.#refData = {};\n    for (const key in data) {\n      if (typeof data[key] === \"object\") {\n        this.#reactiveData[key] = reactive(data[key]);\n        continue;\n      }\n      // currently the only way to re-assign ref-based objects is by using `data.prop = xxx`\n      // directly using `prop = xxx` will not work\n      // TODO: remove limatations on reference objects\n      this.#refData[key] = ref(data[key]);\n    }\n    this.#dataProxy = this.#getDataProxy();\n    window.data = this.#dataProxy;\n    return this;\n  }\n\n  /**\n   * Hook to create computed values with ease.\n   * @param computedValues Functions to calcuate each computed value.\n   * @returns Current `TNTApp` instance.\n   */\n  useComputed(computedValues: TNTComputed) {\n    this.#hooksCalled.push(\"computed\");\n    if (!this.#hooksCalled.includes(\"data\")) {\n      console.warn(\n        \"[TNT warn] useComputed() hook is called before useData(). Any reactive data accessed from computed functions will not be accessable.\",\n        \"This may lead to unpredictable results or errors.\"\n      );\n    }\n    for (const key in computedValues) {\n      this.#computedData[key] = computed(computedValues[key]);\n    }\n    this.#dataProxy = this.#getDataProxy();\n    window.data = this.#dataProxy;\n    return this;\n  }\n\n  /**\n   * Hook to watch effect dependency updates.\n   * @param effect Effect function to watch.\n   * @returns Current `TNTApp` instance.\n   */\n  useEffect(effect: TNTEffect) {\n    this.#hooksCalled.push(\"effect\");\n    this.#watchEffects.push(effect);\n    watchEffect(effect);\n    return this;\n  }\n\n  /**\n   * Run the specified effect when application is mounted.\n   * @param effect Effect to run when application is mounted.\n   * @returns Current `TNTApp` instance.\n   */\n  onMounted(effect: TNTEffect) {\n    this.#onMounted = effect;\n    return this;\n  }\n\n  /**\n   * Remove older child elements.\n   * @param element The root element to check children length.\n   * @param toRemove The child element to remove.\n   */\n  #removeUpdatedElements(element: Element, toRemove: Element) {\n    if (element.children.length > 1) toRemove.remove();\n  }\n}\n\nexport {\n  computed,\n  getTrackableObject,\n  reactive,\n  ref,\n  targetMap,\n  watchEffect,\n} from \"./reactivity\";\nexport { h, mount, patch } from \"./vdom\";\n"],"names":["__classPrivateFieldGet","receiver","state","kind","f","TypeError","has","call","value","get","__classPrivateFieldSet","set","deepClone","obj","newObj","key","evaluate","expression","extraContext","shouldExecuate","func","Function","e","toString","activeEffects","targetMap","WeakMap","getTrackableObject","callbacks","proxy","Proxy","target","result","Reflect","onGet","onSet","deleteProperty","onDeleteProperty","Array","isArray","Object","setPrototypeOf","prototype","track","length","depsMap","Map","dep","Set","forEach","effect","add","trigger","deps","watchEffect","push","pop","reactive","ref","raw","r","newVal","computed","getter","renderer","currentNode","props","startsWith","console","warn","el","removeAttribute","setAttribute","slice","name","shouldFire","node","TAGS_WITH_CONDITION","CONDITION_TAGS","ifRenderer","shouldRender","cond","rendered","elifRenderer","rootVNode","index","previousElement","children","includes","tag","elseRenderer","renderers$1","renderers","data","currentRenderer","expr","split","localName","trim","loopingValue","originalChild","currentData","currentChild","createVNodeFromElement","createVdomFromExistingElement","assign","attributeRenderer","h","mount","vnode","container","document","createElement","addEventListener","toLowerCase","textContent","appendChild","child","createTextNode","patch","n1","n2","oldProps","newProps","oldValue","newValue","oldChildren","newChildren","commonLength","Math","min","i","oldChild","newChild","replaceChild","childNodes","removeChild","Error","getAttributesOfElement","element","attributes","nodeType","Node","TEXT_NODE","ELEMENT_NODE","injectContext","tagName","renderResult","injectVariables","syncData","prop","splice","this","handlers","_TNTApp_reactiveData","_TNTApp_computedData","_TNTApp_refData","_TNTApp_removeUpdatedElements","toRemove","remove","constructor","_TNTApp_dataProxy","_TNTApp_originalData","_TNTApp_onMounted","_TNTApp_hooksCalled","_TNTApp_watchEffects","window","isMounted","prevVdom","currentContainer","_a","newVdom","useData","useComputed","computedValues","useEffect","onMounted"],"mappings":"iCAuOO,SAASA,EAAuBC,EAAUC,EAAOC,EAAMC,GAC1D,GAAa,MAATD,IAAiBC,EAAG,MAAM,IAAIC,UAAU,iDAC5C,GAAqB,mBAAVH,EAAuBD,IAAaC,IAAUE,GAAKF,EAAMI,IAAIL,GAAW,MAAM,IAAII,UAAU,4EACvG,MAAgB,MAATF,EAAeC,EAAa,MAATD,EAAeC,EAAEG,KAAKN,GAAYG,EAAIA,EAAEI,MAAQN,EAAMO,IAAIR,GAGjF,SAASS,EAAuBT,EAAUC,EAAOM,EAAOL,EAAMC,GACjE,GAAa,MAATD,EAAc,MAAM,IAAIE,UAAU,kCACtC,GAAa,MAATF,IAAiBC,EAAG,MAAM,IAAIC,UAAU,iDAC5C,GAAqB,mBAAVH,EAAuBD,IAAaC,IAAUE,GAAKF,EAAMI,IAAIL,GAAW,MAAM,IAAII,UAAU,2EACvG,MAAiB,MAATF,EAAeC,EAAEG,KAAKN,EAAUO,GAASJ,EAAIA,EAAEI,MAAQA,EAAQN,EAAMS,IAAIV,EAAUO,GAASA,EC5OjG,MAAMI,EAAaC,IACxB,MAAMC,EAAc,GACpB,IAAK,MAAMC,KAAOF,EAKhBC,EAAOC,GAJY,iBAARA,EAIGF,EAAIE,GAHFH,EAAUC,EAAIE,IAKhC,OAAOD,GAUIE,EAAW,CACtBC,EACAC,EAAe,GACfC,GAAiB,KAEjB,IACE,MAAMC,EAAOC,SAAS,MAAO,qBAAqBJ,OAClD,OAAOE,EAAiBC,EAAKF,GAAgBE,EAC7C,MAAOE,GACP,OAAOA,EAAEC,aCzBPC,EAA8B,GAEvBC,EAAuB,IAAIC,QAoB3BC,EAAqB,CAChCd,EACAe,KAEA,IAAK,MAAMb,KAAOF,EACQ,iBAAbA,EAAIE,KACbF,EAAIE,GAAOY,EAAmBd,EAAIE,GAAMa,IAG5C,MAAMC,EAAQ,IAAIC,MAAMjB,EAAK,CAC3BJ,IAAIsB,EAAsBhB,EAAad,GACrC,MAAM+B,EAASC,QAAQxB,IAAIsB,EAAQhB,EAAKd,GAExC,OADA2B,EAAUM,MAAMH,EAAQhB,EAAKd,GACtB+B,GAETrB,IAAIoB,EAAsBhB,EAAaP,EAAeP,GAC/B,iBAAVO,IACTA,EAAQmB,EAAmBnB,EAAOoB,IAEpC,MAAMI,EAASC,QAAQtB,IAAIoB,EAAQhB,EAAKP,EAAOP,GAE/C,OADA2B,EAAUO,MAAMJ,EAAQhB,EAAKP,EAAOP,GAC7B+B,GAETI,eAAeL,EAAsBhB,GACnC,MAAMiB,EAASC,QAAQG,eAAeL,EAAQhB,GAE9C,OADAa,EAAUS,iBAAiBN,EAAQhB,GAC5BiB,KAMX,OAHIM,MAAMC,QAAQ1B,IAChB2B,OAAOC,eAAeZ,EAAOS,MAAMI,WAE9Bb,GAQIc,EAAQ,CAACZ,EAAgBhB,KACpC,IAAKS,EAAcoB,OAAQ,OAC3B,IAAIC,EAAUpB,EAAUhB,IAAIsB,GACvBc,IACHA,EAAU,IAAIC,IACdrB,EAAUd,IAAIoB,EAAQc,IAExB,IAAIE,EAAMF,EAAQpC,IAAIM,GACjBgC,IAEHA,EAAM,IAAIC,IACVH,EAAQlC,IAAII,EAAKgC,IAEnBvB,EAAcyB,SAASC,GAAWH,EAAII,IAAID,MAQ/BE,EAAU,CAACrB,EAAsBhB,KAC5C,MAAM8B,EAAUpB,EAAUhB,IAAIsB,GAC9B,IAAKc,EAAS,OACd,MAAMQ,EAAOR,EAAQpC,IAAIM,GACpBsC,GAELA,EAAKJ,SAASC,IACZA,QAQSI,EAAeJ,IAC1B1B,EAAc+B,KAAKL,GACnBA,IACA1B,EAAcgC,OAQHC,EAAY1B,GAChBJ,EAAmBI,EAAQ,CAChCG,MAAMH,EAAQhB,GACZ4B,EAAMZ,EAAQhB,IAEhBoB,MAAMJ,EAAQhB,GACZqC,EAAQrB,EAAQhB,IAElBsB,uBASSqB,EAAOC,IAClB,MAAMC,EAAI,CACJpD,YAEF,OADAmC,EAAMiB,EAAG,SACFD,GAELnD,UAAMqD,GACJA,IAAWF,IACfA,EAAME,EACNT,EAAQQ,EAAG,YAGf,OAAOA,GASIE,EAAYC,IACvB,MAAM/B,EAAS0B,EAAI,MAEnB,OADAJ,GAAY,IAAOtB,EAAOxB,MAAQuD,MAC3B/B,GC9HHgC,EAAqB,CACzBA,SAtBwB,CAACC,EAAoB/C,KAC7C,IAAK,MAAMH,KAAOkD,EAAYC,MACvBnD,EAAIoD,WAAW,OAChBpD,EAAIoD,WAAW,QACjBC,QAAQC,KACN,wHACA,8DAIJJ,EAAYK,GAAGC,gBAAgBxD,GAC/BuC,GAAY,KACVW,EAAYK,GAAGE,aACbzD,EAAI0D,MAAM,GACVzD,EAASiD,EAAYC,MAAMnD,GAAMG,QAIvC,OAAO,GAKPwD,KAAM,oBACNC,WAAWC,GACT,IAAK,MAAM7D,KAAO6D,EAAKV,MACrB,GAAInD,EAAIoD,WAAW,KAAM,OAAO,EAElC,OAAO,ICjCEU,EAAsB,CAAC,OAAQ,UAE/BC,EAAiB,CAAC,OAAQ,SAAU,UAS3CC,EAAa,CAACd,EAAoB/C,KACtC,IAAI8D,GAAe,EAMnB,OALA1B,GAAY,KACV,MAAMtB,EAAShB,EAASiD,EAAYC,MAAMe,KAAM/D,GAChD8D,IAAiBhD,EACjBiC,EAAYC,MAAMgB,SAAWF,EAAazD,cAErCyD,GAaHG,EAAe,CACnBlB,EACA/C,EACAkE,EACAC,KAEA,IAAIL,GAAe,EACnB,MAAMM,EAAmBF,EAAUG,SACjCH,EAAUG,SAAS3C,OAAS,GAE9B,QACEyC,EAAQ,GAAM,IACbR,EAAoBW,SAASF,EAAgBG,MACX,SAAnCH,EAAgBpB,MAAMgB,YAGxB5B,GAAY,KACV,MAAMtB,EAAShB,EAASiD,EAAYC,MAAMe,KAAM/D,GAChD8D,IAAiBhD,EACjBiC,EAAYC,MAAMgB,SAAWF,EAAazD,cAErCyD,IAaHU,EAAe,CACnBzB,EACA/C,EACAkE,EACAC,KAEA,IAAIL,GAAe,EACnB,MAAMM,EAAmBF,EAAUG,SACjCH,EAAUG,SAAS3C,OAAS,GAE9B,QAAIyC,EAAQ,GAAM,IAAMR,EAAoBW,SAASF,EAAgBG,QAErEnC,GAAY,KACV,MAAMtB,EAAShB,EAASsE,EAAgBpB,MAAMe,KAAM/D,GACpD8D,GAAgBhD,EAChBiC,EAAYC,MAAMgB,SAAWF,EAAazD,cAErCyD,ICzCM,IAAAW,EAAA,CAEbC,UAT4B,CCpBH,CACzB5B,SAVuB,CAACC,EAAoB/C,KAC5CoC,GAAY,KACVW,EAAYsB,SAAW,CACrBvE,EAASiD,EAAYC,MAAM2B,KAAM3E,GAAcK,gBAG5C,GAKPmD,KAAM,mBACNC,WAAWC,GACW,MAAbA,EAAKa,KF+FW,CACzBzB,SAlBwB,CACxBC,EACA/C,EACAkE,EACAC,KAEA,IAAIS,EAAkB,KAQtB,OANEA,EADsB,SAApB7B,EAAYwB,IACIV,EACW,WAApBd,EAAYwB,IACHN,EAEAO,EAEbI,EAAgB7B,EAAa/C,EAAckE,EAAWC,IAK7DX,KAAM,oBACNC,WAAWC,GACFE,EAAeU,SAASZ,EAAKa,MG3Fb,CACzBzB,SAnBmB,CAACC,EAAoB/C,KACxC,MAAM6E,EAAO9B,EAAYC,MAAM2B,KAAKG,MAAM,QACpCC,EAAYF,EAAK,GAAGG,OACpBC,EAAenF,EAAS+E,EAAK,GAAGG,OAAQhF,GACxCkF,EAAyBxF,EAAUqD,EAAYK,GAAGiB,SAAS,IACjE,IAAK,MAAMc,KAAeF,EAAc,CACtC,MAAMG,EAAeC,EAAuBH,GAE5CI,EAA8BF,EAAcA,EAAahC,GAAE9B,OAAAiE,OAAAjE,OAAAiE,OAAA,GACtDvF,GAAY,CACf+E,CAACA,GAAYI,KAEdpC,EAAYsB,SAAqBhC,KAAK+C,GAGzC,OAAO,GAKP5B,KAAM,eACNC,WAAWC,GACW,UAAbA,EAAKa,KFQdiB,IGlBK,MAAMC,EAAI,CACflB,EACAvB,EAAgC,GAChCqB,EACAjB,KAEO,CAAEmB,MAAKvB,QAAOqB,WAAUjB,OASpBsC,EAAQ,CACnBC,EACAC,EACA5F,EAAuB,MAEvB,MAAMoD,EAAMuC,EAAMvC,GAAKyC,SAASC,cAAcH,EAAMpB,KAEpD,IAAK,MAAM1E,KAAO8F,EAAM3C,MAAO,CAC7B,MAAM1D,EAAQqG,EAAM3C,MAAMnD,GACtBA,EAAIoD,WAAW,OACjBG,EAAG2C,iBACDlG,EAAI0D,MAAM,GAAGyC,cACblG,EAASR,EAAOU,IAElB2F,EAAMvC,GAAGC,gBAAgBxD,IAG3BuD,EAAGE,aAAazD,EAAKP,GAOvB,OAJIkG,EAAkB/B,WAAWkC,IAC/BH,EAAkB1C,SAAS6C,EAAO3F,GAGN,iBAAnB2F,EAAMtB,UACfjB,EAAG6C,YAAcN,EAAMtB,cACvBuB,EAAUM,YAAY9C,KAGxBuC,EAAMtB,SAAStC,SAASoE,IACD,iBAAVA,EAIXT,EAAMS,EAAO/C,EAAIpD,GAHfoD,EAAG8C,YAAYL,SAASO,eAAeD,OAK3CP,EAAUM,YAAY9C,GACfwC,IASIS,EAAQ,CAACC,EAAWC,EAAWvG,EAAuB,MACjE,GAAIsG,EAAG/B,MAAQgC,EAAGhC,IAAK,CACrB,MAAMnB,EAAMmD,EAAGnD,GAAKkD,EAAGlD,GAEjBoD,EAAWF,EAAGtD,OAAS,GACvByD,EAAWF,EAAGvD,OAAS,GAC7B,IAAK,MAAMnD,KAAO4G,EAAU,CAC1B,MAAMC,EAAWF,EAAS3G,GACpB8G,EAAWF,EAAS5G,GACtB8G,IAAaD,GACjBtD,EAAGE,aAAazD,EAAK8G,GAEvB,IAAK,MAAM9G,KAAO2G,EACV3G,KAAO4G,GACXrD,EAAGC,gBAAgBxD,GAKvB,MAAM+G,EAAcN,EAAGjC,SACjBwC,EAAcN,EAAGlC,SACjByC,EAAeC,KAAKC,IAAIJ,EAAYlF,OAAQmF,EAAYnF,QAC9D,IAAK,IAAIuF,EAAI,EAAGA,EAAIH,EAAcG,IAAK,CACrC,MAAMC,EAAWN,EAAYK,GACvBE,EAAWN,EAAYI,GACL,iBAAbC,GACe,iBAAbC,EAUbd,EAAMa,EAAmBC,GATjBD,IAAaC,GACf/D,EAAGgE,aACDvB,SAASO,eAAee,GACxB/D,EAAGiE,WAAWJ,IAQxB,OAAIJ,EAAYnF,OAASkF,EAAYlF,YACnCmF,EAAYtD,MAAMqD,EAAYlF,QAAQK,SAASoE,IACxB,iBAAVA,EAIXT,EAAMS,EAAO/C,EAAIpD,GAHfoD,EAAG8C,YAAYL,SAASO,eAAeD,OAOzCU,EAAYnF,OAASkF,EAAYlF,YACnCkF,EACGrD,MAAMsD,EAAYnF,QAClBK,SAAQ,CAACoE,EAAmBhC,KACN,iBAAVgC,EAIX/C,EAAGkE,YAAYnB,EAAM/C,IAHnBA,EAAGkE,YAAYlE,EAAGiE,WAAWlD,YAOrC,EAEF,MAAM,IAAIoD,MAAM,+CAQLC,EACXC,IAEA,MAAMC,EAAa,GACnB,IAAK,IAAIT,EAAI,EAAGA,EAAIQ,EAAQC,WAAWhG,OAAQuF,IAC7CS,EAAWD,EAAQC,WAAWT,GAAGzD,MAAQiE,EAAQC,WAAWT,GAAG3H,MACjE,OAAOoI,GASIpC,EAAgC,CAC3CpB,EACA0B,EACA5F,EAAuB,MAEvB,IAAI4F,EAAUyB,YAAYtF,SAAQ,CAACoE,EAAgBhC,KACjD,GAAIgC,EAAMwB,WAAaC,KAAKC,UAAW,CACrC,IAAK1B,EAAMF,YAAYjB,OAAQ,OAE/B,YADAd,EAAUG,SAAShC,KAAK8D,EAAMF,aAIhC,GAAIE,EAAMwB,WAAaC,KAAKE,aAC1B,OAEF,IAAIhE,GAAe,EACfiE,EAAgB/H,EACpB,MAAM+C,EAAc0C,EAClBU,EAAM6B,QAAQhC,cACdwB,EAAuBrB,GACvB,IAEFpD,EAAYK,GAAK+C,EAEjBzB,EAAUA,UAAU3C,SAASe,IAC3B,IAAKA,EAASW,WAAWV,GAAc,OACvC,MAAMkF,EAAenF,EAASA,SAC5BC,EACAgF,EACA7D,EACAC,GAE0B,kBAAjB8D,GAIXnE,EAAemE,EAAanE,cAAgBA,EAC5CiE,iCAAqBA,GAAkBE,EAAaC,kBAJlDpE,EAAgBmE,EAA8BnE,EAAfmE,KAM/BnE,GACFwB,EAA8BvC,EAAaoD,EAAO4B,GAEnD7D,EAAUG,SAAqBhC,KAAKU,OAW5BsC,EAA0B3B,GAC9B+B,EAAE/B,EAAKsE,QAAQhC,cAAewB,EAAuB9D,GAAO,GAAIA,+KCpGrE,MAAMyE,EAAW,CAACtH,EAAqBuH,EAAc9I,KAE/C8B,MAAMC,QAAQ/B,KAIhBuB,EAAO0B,SAAS6F,GAAMC,OAAO,EAAGxH,EAAO0B,SAAS6F,GAAM1G,QACtDb,EAAO0B,SAAS6F,GAAM/F,QAAQ/C,IAGhC4C,EAAQpD,EAAAwJ,YAAoBF,IAGxBG,EAAW,CACfhJ,IAAG,CAACsB,EAAqBuH,IACnBA,KAAQvH,EAAO0B,SACV1B,EAAO0B,SAAS6F,GAErBA,KAAQvH,EAAO+B,SACV/B,EAAO+B,SAASwF,GAAM9I,MAE3B8I,KAAQvH,EAAO2B,IACV3B,EAAO2B,IAAI4F,GAAM9I,WAE1B4D,QAAQC,KACN,yDAAyDiF,QAI7D3I,IAAG,CAACoB,EAAqBuH,EAAc9I,IACjC8I,KAAQvH,EAAO0B,UACjB4F,EAAStH,EAAQuH,EAAM9I,IAChB,GAEL8I,KAAQvH,EAAO2B,KACjB3B,EAAO2B,IAAI4F,GAAM9I,MAAQA,GAClB,IAET4D,QAAQC,KACN,oDAAoDiF,SAE/C,IAIX,OAAO,IAAIxH,MACT,CACE2B,SAAUzD,EAAAwJ,KAAkBE,EAAA,KAC5B5F,SAAU9D,EAAAwJ,KAAkBG,EAAA,KAC5BjG,IAAK1D,EAAAwJ,KAAaI,EAAA,MAEpBH,IAEHI,EAAA,SA2EsBlB,EAAkBmB,GACnCnB,EAAQpD,SAAS3C,OAAS,GAAGkH,EAASC,yBApN5CC,0BAhBAN,EAAsB/I,IAAA6I,UAAA,GAEtBG,EAAsBhJ,IAAA6I,UAAA,GAEtBI,EAAiBjJ,IAAA6I,UAAA,GAEjBS,EAAmBtJ,IAAA6I,UAAA,GAEnBU,EAAsBvJ,IAAA6I,UAAA,GAEtBW,EAAkCxJ,IAAA6I,UAAA,GAElCY,EAAuBzJ,IAAA6I,UAAA,GAEvBa,EAA2B1J,IAAA6I,UAAA,GAGzB9I,EAAA8I,KAAkBW,GAAA,aAClBzJ,EAAA8I,KAAIY,EAAgB,GAAE,KACtB1J,EAAA8I,KAAIG,EAAiB,GAAE,KACvBjJ,EAAA8I,KAAIE,EAAiB,GAAE,KACvBhJ,EAAA8I,KAAII,EAAY,GAAE,KAClBlJ,EAAA8I,KAAIa,EAAiB,GAAE,KACvB3J,EAAA8I,KAAIU,EAAiB,GAAE,KACvBI,OAAOzE,KAAO,GAQhBe,MAAME,GACJ,IAAIyD,GAAY,EACZC,EAAyB,KACzBvG,EAAc,KAgDlB,OA/CAjE,EAAAwJ,KAAiBY,EAAA,KAAC7G,KAAK,SAGvBD,GAAY,WACV,MAAMmH,UAAmBC,EAAAzG,aAAA,EAAAA,EAAaK,kBAAMwC,EAAUvB,SAAS,GACzDsB,EAAQF,EACZ8D,EAAiBvB,QACjBR,EAAuB+B,GACvB,IAEIvJ,EACDsB,OAAAiE,OAAA,GAAAzG,EAAAwJ,KAAIE,EAAA,MAGT,IAAK,MAAM3I,KAAOf,EAAAwJ,YAIhBtI,EAAaH,GAAOf,EAAAwJ,KAAkBG,EAAA,KAAC5I,GAEzC,IAAK,MAAMA,KAAOf,EAAAwJ,YAGhBtI,EAAaH,GAAOf,EAAAwJ,KAAaI,EAAA,KAAC7I,GAUpC,GARA8F,EAAMvC,GAAKmG,EACXjE,EAA8BK,EAAO4D,EAAkBvJ,GACvD+C,EAAc0C,EACZG,EAAUoC,QACVR,EAAuB+B,GACvB5D,EAAMtB,SACNkF,IAEGF,EAMH,OALAC,EAAW5J,EAAUqD,GACrB2C,EAAM4D,EAAU1D,EAAW5F,GAC3BqJ,GAAY,EACZvK,EAAAwJ,cAAAjJ,KAAAiJ,KAA4B1C,EAAW2D,QACvCzK,EAAAwJ,KAAeW,EAAA,KAAA5J,KAAfiJ,KAAgBA,MAGlB,MAAMmB,EAAiB/J,EAAUqD,GACjCsD,EAAMiD,EAAUG,EAASzJ,GACzBsJ,EAAW5J,EAAU+J,GACrB3K,EAAAwJ,cAAAjJ,KAAAiJ,KAA4B1C,EAAW2D,MAGlCjB,KAIL3D,WACF,OAAO7F,EAAAwJ,KAAIS,EAAA,KAuEbW,QAAQ/E,GACN7F,EAAAwJ,KAAiBY,EAAA,KAAC7G,KAAK,QACvB7C,EAAA8I,KAAqBU,EAAAtJ,EAAUiF,QAC/BnF,EAAA8I,KAAIE,EAAiB,GAAE,KACvBhJ,EAAA8I,KAAII,EAAY,GAAE,KAClB,IAAK,MAAM7I,KAAO8E,EACS,iBAAdA,EAAK9E,GAOhBf,EAAAwJ,KAAII,EAAA,KAAU7I,GAAO2C,EAAImC,EAAK9E,IAN5Bf,EAAAwJ,KAAIE,EAAA,KAAe3I,GAAO0C,EAASoC,EAAK9E,IAU5C,OAFAL,EAAA8I,OAAkBxJ,EAAAwJ,cAAAjJ,KAAAiJ,MAAoB,KACtCc,OAAOzE,KAAO7F,EAAAwJ,YACPA,KAQTqB,YAAYC,GACV9K,EAAAwJ,KAAiBY,EAAA,KAAC7G,KAAK,YAClBvD,EAAAwJ,KAAIY,EAAA,KAAc5E,SAAS,SAC9BpB,QAAQC,KACN,uIACA,qDAGJ,IAAK,MAAMtD,KAAO+J,EAChB9K,EAAAwJ,KAAIG,EAAA,KAAe5I,GAAO+C,EAASgH,EAAe/J,IAIpD,OAFAL,EAAA8I,OAAkBxJ,EAAAwJ,cAAAjJ,KAAAiJ,MAAoB,KACtCc,OAAOzE,KAAO7F,EAAAwJ,YACPA,KAQTuB,UAAU7H,GAIR,OAHAlD,EAAAwJ,KAAiBY,EAAA,KAAC7G,KAAK,UACvBvD,EAAAwJ,KAAkBa,EAAA,KAAC9G,KAAKL,GACxBI,EAAYJ,GACLsG,KAQTwB,UAAU9H,GAER,OADAxC,EAAA8I,KAAIW,EAAcjH,EAAM,KACjBsG"}